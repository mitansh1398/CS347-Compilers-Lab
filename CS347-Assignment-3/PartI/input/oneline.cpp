#include <bits/stdc++.h>using namespace std;struct Node{    Node *Down , *Right ;    int row , col  ,val;};class SparseMatrix{private:	Node Root;	Node **Heads;public:	SparseMatrix(int row , int col , int elements); 	Node *CreateNode(int row , int col , int val); 	void BuildMatrix(); 	bool InsertNode(Node *NodeToInsert); 	int RandomRow(); 	int RandomCol(); 	int RandomVal(); 	Node * HighsetValue(); };int main(){		srand(time(NULL));	    int row , col , elements;    cout<<"Enter the number of Rows:\t";    cin>>row;    cout<<"Enter the number of Columns:\t";    cin>>col;    cout<<"Enter the number of Elements:\t";    cin>>elements;        if (elements > row*col)    {    	cout<<"ERROR OVERFLOW : Number of elements entered is more than the size of the sparse matrix."<<endl;    	return 0;    }    if (elements < 0)    {    	cout<<"ERROR : Please enter valid number of elements."<<endl;    	return 0;    }        SparseMatrix SM(row ,col ,elements);            SM.BuildMatrix();            Node * HightestValNode = SM.HighsetValue();    if (HightestValNode == NULL)    {    	cout<<"Sparse Matrix is empty."<<endl;    	cout<<"Hence there is no highest value."<<endl;    }    else    {	    cout<<"Highest value in the sparse matrix is:\t"<<HightestValNode->val<<endl;	}    return 0;}SparseMatrix::SparseMatrix(int row , int col , int elements){		Root.row = row;	Root.col = col;	Root.val = elements;		int n = max(row , col);	Heads = new Node*[n+1];		for (int i = 1; i <= n; ++i)	{		Heads[i] = new Node;	}		Root.Down = Heads[1];	Root.Right = Heads[1];		int i;	for (i = 1; i <= n; ++i)	{				Heads[i]->Down = Heads[i];		Heads[i]->Right = Heads[i];						Heads[i]->row = 0;		Heads[i]->col = 0;		Heads[i]->val = 0;	}}Node* SparseMatrix::CreateNode(int row , int col , int val){		Node * temp = new Node;		temp->row = row;	temp->col = col;	temp->val = val;	return temp ;}void SparseMatrix::BuildMatrix(){		int Counter = 0;		while(Counter < Root.val)	{				int i , j , val;		i = RandomRow();		j = RandomCol();		val = RandomVal();				Node *temp = CreateNode(i , j , val);						if(InsertNode(temp))		{			Counter++;		}		else		{			delete(temp);		}	}}bool SparseMatrix::InsertNode(Node *NodeToInsert){	int row = NodeToInsert->row;	int col = NodeToInsert->col;		Node * ColPtr1 = Heads[col];	Node * ColPtr2 = ColPtr1->Down;		while(ColPtr2 != Heads[col] && ColPtr1->row < row)	{		ColPtr1 = ColPtr2;		ColPtr2 = ColPtr2->Down;	}	if (ColPtr1->row == row)	{		return false;	}		Node * RowPtr1 = Heads[row];	Node * RowPtr2 = RowPtr1->Right;		while(RowPtr2 != Heads[row] && RowPtr1->col < col)	{		RowPtr1 = RowPtr2;		RowPtr2 = RowPtr2->Right;	}	if (RowPtr1->col == col)	{		return false;	}			ColPtr1->Down = NodeToInsert;	NodeToInsert->Down = ColPtr2;		RowPtr1->Right = NodeToInsert;	NodeToInsert->Right = RowPtr2;		return true;}int SparseMatrix::RandomRow(){	return rand()%Root.row +1;}int SparseMatrix::RandomCol(){	return rand()%Root.col +1;}int SparseMatrix::RandomVal(){	return rand()%1000000 +1;}Node * SparseMatrix::HighsetValue(){	static int count = 1;	int max = INT_MIN;	Node * HightestValNode = NULL;	for (int i = 1; i <= Root.row; ++i)	{				Node * NodePtr = Heads[i]->Right;		while(NodePtr != Heads[i])		{			if (NodePtr->val > max)			{				max = NodePtr->val;				HightestValNode = NodePtr;			}			cout<<count++<<"\t"<<NodePtr->val<<endl;			NodePtr = NodePtr->Right;		}	}	return HightestValNode;}